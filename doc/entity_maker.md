# API Entity Maker
@TODO Add assert support for field definition

This feature allows to generate concrete entities which are compatible with API Entity defined in this library. It's used to generate some entities already defined here, but it can be reused by you for your own entities.

## Add own entity maker command
### 1. Create a maker class
Create a new class in `App\Maker` namespace; class should extend `ApiCommon\Maker\Entity\AbstractEntityMaker`:
```php
<?php declare(strict_types=1);

namespace App\Maker;

 

class MakeUser extends AbstractEntityMaker
{
    
}
```
If the location of maker class does not follow Symfony rules or autoconfiguration is disabled, you should mark the maker class with tag `maker.command`, eg.:
```yaml
app.maker.user:
    class: App\Maker\MakeUser
    tags: [ 'maker.command' ]
```
### 2. Specify maker command name
Implement `getCommandName` method where command is a name used in `bin/console`:
```php
public static function getCommandName(): string
{
    return 'make:entities:user';
}
```
### 3. Configure command
Implement `configureCommand` method to specify a configuration of the command, eg. options:
```php
public function configureCommand(Command $command, InputConfiguration $inputConfig)
{
    $command
        ->addOption('overwrite', null, InputOption::VALUE_NONE, 'Overwrite any existing getter/setter methods');
}
```
### 4. Specify command description
Implement `getCommandDescription` method to return simple command description
```php
public static function getCommandDescription(): string
{
    return 'Create application user entity';
}
```
### 5. Specify entity class name
Implement `getEntityClassName` method to return entity class name:
```php
public static function getEntityClassName(): string
{
    return 'User';
}
```
**IMPORTANT!** This class name should not contain full path, but only class name. Full class name is generated by adding `APP_PREFIX\Entity\` part at start (where `APP_PREFIX` is an application prefix which can be configured; default it's `App`).
If you want to nest entity class deeper, you can do it by returning value like this:
```php
public static function getEntityClassName(): string
{
    return 'Config\\ConfigGroup';
}
```
In the example above entity class will be generated with `App\Entity\Config\ConfigGroup` namespace and located in file with proper directory.

### 6. Specify other options
#### a) table name
Table name is automatically generated based on entity name. However, you can specify your own name by implementing `getTableName` method in a maker class:
```php
public static function getTableName(): ?string
{
    return 'config_groups';
}
```
#### b) API resource
You can mark entity as API resource if you implement `isApiResource` method and return true there:
```php
public static function isApiResource(): bool
{
    return true;
}
```
This method defined in abstract maker returns `false`.
#### c) repository class
You can determine if repository class should be generated automatically too by implementing `isRepositoryGenerated` method:
```php
public static function isRepositoryGenerated(): bool
{
    return false;
}
```
This method defined in abstract maker returns `false`.
#### d) unique fields
You can add a list of fields which set must be unique in the table in database. To do this implement `getUniqueConstraintFields` method and return array with names of entity fields:
```php
public static function getUniqueConstraintFields(): array
{
    return [
        'email',
        'username'
    ];
}
```
The example above will add the annotation: `#[UniqueEntity(['email', 'username'])]` to created entity.
This method defined in abstract maker returns no fields.

### 7. Specify interfaces and traits
You can add an interface or a trait to your entity.

#### a) interfaces
Interfaces are specified in `getInterfaces` method implemented in a maker class. It should return an array with full interface names, eg:
```php
public function getInterfaces(): array
{
    return [
        \Symfony\Component\Security\Core\User\UserInterface::class
    ];
}
```
This method defined in abstract maker returns no interfaces.

#### b) traits
Traits are specified in `getTraits` method implemented in a maker class. It should return an array with full interface names, eg:
```php
public function getTraits(): array
{
    return [
        \ApiPlatform\Doctrine\Common\Filter\DateFilterTrait::class
    ];
}
```
This method defined in abstract maker returns no traits.

### 8. Specify maker dependencies
There cna be a situation when you create two different entities by two makers and there is a relation between these entities. You can run these makers one by one and generate classes separately however when first class is being created, there is no second one created yet.
You can implement then `getDependencies` method in these makers and return there array of maker's class names where other related entity are being generated. It will make sure that in a case when during relation creation an entity class doesn't exist, its skeleton will be created on demand there. Later, its maker will just do remaining job.
Example implementation:
```php
public function getDependencies(): array
{
    return [
        ApiCommon\Maker\Entity\Config\ValueMaker::class,
        ApiCommon\Maker\Entity\Config\ConfigGroupMaker::class
    ];
}
```

### 9. Specify entity generation
Fields added to an entity are specified in `getFields` method. It is a generator yielding values of type `EntityField` or `EntityRelation`. It's described deeply in a section below. Simple example of implementation of this method is:
```php
public function getFields(): Generator
{
    yield new EntityField('label', Types::STRING, false, ['length' => 255]);
    yield new EntityField('sortOrder', Types::INTEGER);
}
```

## Entity parts generation
Entity properties can contain both fields and relations. Both types can be defined in `getFields` method.

### Entity field generation
It's represented by `ApiCommon\Model\Maker\Entity\EntityField` class. Below are described all defined fields:
* `fieldName` - name of a property; it's a name of a column in a database and it's used for getter/setter generation;
* `type` - Doctrine type, used to determine column type in a database; if `propertyType` is not set, `type` is used to determine PHP property type;
* `nullable` - a flag determines if field can be nullable or not;
* `propertyType` - it determines a PHP type for entity property; it's used for getter/setter generation too; if it's a class name, eg. `ApiCommon\Entity\Config\DefinitionInterface`, then the class is automatically imported in entity file;
* `blank` - a flag determines if field can be blank; if not, then for strings only an assertion is generated.

Example field definition in `getFields` method:
```php
// integer value:
yield new EntityField('sortOrder', Types::INTEGER);
// string value:
yield new EntityField('backendModel', Types::STRING, false, ['length' => 255]);
// nested object serialized internally to JSON:
yield new EntityField('metadata', Types::JSON, false, [], Metadata::class);
```

### Entity relation generation
It's represented by `ApiCommon\Model\Maker\Entity\EntityRelation` class.

The constructor takes fields:
* `type` - type of relation, one of constant defined in the relation class, eg. `MANY_TO_ONE`;
* `owningClass` - full class name of an entity which is owned the relation (it means entity keeps information about relation binding); mainly it's an entity generated by a current maker;
* `inverseClass` - full class name of an entity which is a second member of the relation and has just inverse access to information about it.

The class has some methods to specify more information:
* `setOwningProperty` - takes a name of a relation property in an owning entity;
* `setInverseProperty` - takes a name of a relation property in an inverse entity;
* `setMapInverseRelation` - determines if inverse relation should be mapped; if it's set to `false`, then you must not use `setInverseProperty` method;
* `setColumnName` - can change default column name where is kept foreign key to a second table; it should be used only in specific cases;
* `setIsNullable` - determines if there can be NULL in owning entity; it allows to have entity objects not related to other entity;
* `setIsCustomReturnTypeNullable` - determines if custom return type used in getter and setter methods is nullable;
* `setOrphanRemoval` - determines if orphans can be deleted too after removing related entity;
* `setCustomReturnType` - determines PHP real type of entity field in an owning one, eg. in a property can be entity but its type can be an interface, not entity class;
* `setCustomInverseReturnType` - determines PHP real type of entity field in an inverse one, eg. in a property can be entity but its type can be an interface, not entity class.

Example relation definition in `getFields` method:
```php
$groupRelation = new EntityRelation(
    EntityRelation::MANY_TO_ONE,
    $this->classNameResolver->resolve(self::getEntityClassName()),
    $this->classNameResolver->resolve(ConfigGroupMaker::getEntityClassName())
);
$groupRelation->setOwningProperty('configGroup');
$groupRelation->setInverseProperty('definitions');
$groupRelation->setIsNullable(false);
$groupRelation->setOrphanRemoval(true);
$groupRelation->setCustomReturnType(GroupInterface::class);
$groupRelation->setCustomInverseReturnType(DefinitionInterface::class);
yield $groupRelation;
```

**IMPORTANT!** In the case shown above don't forget to specify `ConfigGroupMaker` in array returned by `getDependencies` method.

## Most important components
### `ApiCommon\Maker\Entity\AbstractEntityMaker`
This is an abstract entity maker class. Custom makers must extend it to get benefits and be able to use additional logic.
Internal methods:
* `getCommandName` - return the command name for your maker;
* `getCommandDescription` - return the command description;
* `configureCommand` - configure the command: set description, input arguments, options, etc.;
* `configureDependencies` - configure any library dependencies (by specifying concrete classes) that your maker requires;
* `generate` - does the main logic where entity class is generated.

### `ApiCommon\Maker\Util\ClassSourceManipulator`
It is responsible for adding properties with getters and setters to the class. A lot of logic is common with the original class in Symfony however that class was permitted to be extended.
Features added to this version of class:
* define PHP property type (used in a getter/setter too) separately from Doctrine type;
* add Symfony asserts to entity fields.

### `ApiCommon\Model\Maker\Entity\EntityClassGenerator`
It is responsible for generating skeleton of entity class. Original class was overwritten for some purposes:
* specifying own entity template file;
* allowing to determine if to generate a repository for an entity;
* changing 'id' type to Uuid.

## Built-in entity makers:
| Command name                     | Maker class                         | Description                                                                                                          |
|----------------------------------|-------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| bin/console make:entities:config | \ApiCommon\Maker\Entity\ConfigMaker | Generates configuration entities:<br>* Config\ConfigGroup<br>* Config\Definition<br>* Config\Scope<br>* Config\Value |
| make:entities:user               | \ApiCommon\Maker\Entity\UserMaker   | Generates User entity                                                                                                |